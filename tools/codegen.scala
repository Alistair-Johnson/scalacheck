// Generates Arbitrary instance for tuples and functions
// see src/main/scala/org/scalacheck/ArbitraryArities.scala

def csv(s: Seq[String]) = s mkString ", "
def typed(s: Seq[(String,String)]) = s map { case (v,t) => s"$v:$t"}
def wrapType(t: String, w:String) = s"$w[$t]"

def idents(name: String, i: Int) = 1 to i map(i0 => name+i0)
def types(i: Int) = idents("T",i).mkString(",")

def valsWithTypes(i: Int) =
  idents("t",i) zip
  idents("T",i) map
  { case (v,t) => s"$v:$t"} mkString ","

def wrappedArgs(wrapper: String, i: Int) = 
  csv(typed(
    idents(wrapper.take(1).toLowerCase,i) zip
    idents("T",i).map(wrapType(_,wrapper))
  ))

def generators(s: Seq[(String,String)]) =
  s map { case (v,a) => s"$v<-$a"} mkString "; "

def vals(i: Int) = csv(idents("t",i))

def function(i: Int) = s"""
  /** Arbitrary instance of Function${i} */
  implicit def arbFunction${i}[${types(i)},R]
    (implicit a: Arbitrary[R]): Arbitrary[(${types(i)}) => R]
    = Arbitrary(
        for(r <- a.arbitrary) yield (${valsWithTypes(i)}) => r
      )
  """

def tuple(i: Int) = {
  val gens = generators(
    idents("t",i) zip
    idents("a",i).map(_+".arbitrary")
  )
  s"""
  /** Arbitrary instance of ${i}-Tuple */
  implicit def arbTuple$i[${types(i)}](implicit
    ${wrappedArgs("Arbitrary",i)}
  ): Arbitrary[(${types(i)})]
    = Arbitrary(for {
        ${gens}
      } yield (${vals(i)}))
  """
}

def zip(i: Int) = {
  val gens = generators(idents("t",i) zip idents("g",i))
  def sieveCopy = idents("g",i) zip idents("t",i) map { case (g,t) => s"$g.sieveCopy($t)" } mkString " && "
  s"""
  /** Combines the given generators into one generator that produces a
   *  tuple of their generated values. */
  def zip[${types(i)}](
    ${wrappedArgs("Gen",i)}
  ): Gen[(${types(i)})] = {
    val g = for {
      ${gens}
    } yield (${vals(i)})
    g.suchThat {
      case (${vals(i)}) =>
        ${sieveCopy}
    }
  }
  """
}

def resultOf(i: Int) = {
  def delegate = idents("T",i).drop(1).map("_:"+_).mkString(",")
  s"""
  /** Takes a function and returns a generator that generates arbitrary
   *  results of that function by feeding it with arbitrarily generated input
   *  parameters. */
  def resultOf[${types(i)},R]
    (f: (${types(i)}) => R)
    (implicit
      ${wrappedArgs("Arbitrary",i)}
    ): Gen[R] = arbitrary[T1] flatMap {
      t => resultOf(f(t,$delegate))
    }
  """
}

println(
  if(args(0) == "Arbitrary"){

    s"""/**
Defines implicit [[org.scalacheck.Arbitrary]] instances for tuples and functions

Autogenerated using tools/codegen.sh
*/
package org.scalacheck
private[scalacheck] trait ArbitraryArities{
  // Functions //
  ${1 to 22 map function mkString ""}

  // Tuples //
  ${2 to 22 map tuple mkString ""}
}"""

  }else{

    s"""/**
Defines zip and resultOf for all arities

Autogenerated using tools/codegen.sh
*/
package org.scalacheck
private[scalacheck] trait GenArities{
  // zip //
  ${1 to 22 map zip mkString ""}

  // resultOf //
  import Arbitrary.arbitrary
  def resultOf[T,R](f: T => R)(implicit a: Arbitrary[T]): Gen[R]
  ${2 to 22 map resultOf mkString ""}
}"""

  }
)
